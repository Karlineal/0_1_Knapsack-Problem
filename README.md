# 0-1 背包问题的多种算法实现与性能分析

## 1. 项目概述 (Project Overview)

本项目是《算法设计与分析》课程的课外实验作业，旨在通过C语言实现并分析解决经典0-1背包问题的四种不同算法：蛮力法、动态规划法、贪心法和回溯法。实验的核心目标是比较这些算法在不同输入规模下的性能表现（主要关注执行时间），并结合理论时间复杂度进行分析，从而加深对算法设计思想和复杂度概念的理解。

**学生信息 (Student Information):**
* **姓名 (Name):** 彭家城 (Peng Jiacheng)
* **学号 (Student ID):** 20231060285
* **班级 (Class):** 计科班 (Computer Science Class)
* **学校 (University):** 云南大学 (Yunnan University)
* **课程 (Course):** 算法设计与分析 (Algorithm Design and Analysis)
* **指导教师 (Instructor):** 段亮

## 2. 算法实现 (Algorithms Implemented)

本项目实现了以下四种解决0-1背包问题的算法：

1.  **蛮力法 (Brute Force):**
    * 通过枚举所有可能的物品组合 ($2^n$ 种) 来找到最优解。
    * 适用于物品数量 $n$ 非常小的情况。代码中设置了 `MAX_N_FOR_BRUTE_FORCE` (例如22) 作为实际运行的上限。
2.  **动态规划法 (Dynamic Programming):**
    * 采用二维DP表 `dp[i][j]` 存储考虑前 $i$ 个物品、背包容量为 $j$ 时的最大价值。
    * 时间复杂度为 $O(nC)$，空间复杂度为 $O(nC)$。代码中设置了 `MAX_DP_ELEMENTS` (例如 $2.5 \times 10^8$) 作为DP表元素数量的上限，以防止内存溢出。
3.  **贪心法 (Greedy Algorithm):**
    * 优先选择单位重量价值最高的物品放入背包。
    * 时间复杂度为 $O(n \log n)$（主要为排序时间）。
    * 此算法不保证得到最优解，但执行速度快。
4.  **回溯法 (Backtracking):**
    * 通过深度优先搜索解空间树，并使用剪枝策略（约束函数和限界函数）来优化搜索过程。
    * 最坏时间复杂度为 $O(2^n)$，但通常优于蛮力法。代码中也设置了与蛮力法类似的 `N` 值上限，因为无强剪枝的回溯在大规模数据下仍可能超时。

## 3. 实验设置 (Experimental Setup)

* **编程语言 (Programming Language):** C
* **编译环境 (Compilation Environment):** GNU GCC Compiler (MinGW-w64) (例如版本 8.1.0，请根据您的实际环境填写)
* **开发工具 (IDE):** Code::Blocks (或其他C语言开发环境)
* **测试数据规模 (Test Data Scale):**
    * 物品数量 $n$：从较小值（如4, 10, 15, 20）到大规模值 [1000, 2000, ..., 320000]。
    * 背包容量 $C$：[10000, 100000, 1000000]。
    * 物品属性：每个物品重量为 [1, 100] 范围内的随机整数，价值为 [100.00, 1000.00] 范围内的随机浮点数（保留两位小数）。
* **性能度量 (Performance Metrics):**
    * 主要关注算法核心逻辑的执行时间，使用C语言的 `clock()` 函数测量，单位为毫秒 (ms)。
    * 输出结果包括最大价值、选中物品的详细信息（编号、重量、价值）、选中物品的总重量。
